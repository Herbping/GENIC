
import java.util.*;
import java.util.Map.Entry;

import com.microsoft.z3.*;
public class PDR {
	private final List<Expr> R = new ArrayList<>();
	private final Map<Cube,Cube> chains = new HashMap<>();
	private Context ctx;
	private Integer N = 0;
	protected final Expr I;
	protected final Expr T;
	protected final Expr P;


	public void check(){
		R.add(I);
		while(true){
			Expr query = ctx.mkAnd((BoolExpr)R.get(N),ctx.mkNot((BoolExpr) P));
			Optional<Model> result = check(ctx,(BoolExpr) query,Status.SATISFIABLE);
			if(result.isPresent()){
				Model mo = result.get();
				Cube m = ModeltoCube(mo);
				Cube t = generalizeSat(m, query);
			}
		}
	}
	
	
	private void block(Cube s0, Integer k0){
		PriorityQueue<Entry<Cube,Integer>> Q = new PriorityQueue<>();
		Q.add(new AbstractMap.SimpleEntry<Cube, Integer>(s0, k0));
		
		while(!Q.isEmpty()){
			Entry<Cube, Integer> en = Q.poll();
			Cube s = (Cube) en.getKey();
			int k = en.getValue();
			
			if(k == 0){
				if(check(ctx,(BoolExpr) ctx.mkAnd(CubetoExpr(s),(BoolExpr)I),Status.SATISFIABLE).isPresent())
					return null;
			}
		}
	}
	
	// Constrain Cube c on Expr query
	private Cube generalizeSat(Cube c, Expr query){
		Map<Symbol,Boolean> interp = c.toInterpretation();
		// constrain interp on query, that is, deleting 
		for (Expr v: c.getVars()){
			// if a var is not prime
			if(!v.getFuncDecl().getName().toString().substring(v.getFuncDecl().getName().toString().length() - 1).equals('\'')){
				Map<Symbol,Boolean> reduced = new HashMap<Symbol,Boolean>();		// construct a reduced interpretation by deleting v from interp
				for(Symbol s: interp.keySet()){
					if(!s.toString().equals(v.getFuncDecl().getName().toString()))	// if s =/= v
						reduced.put(s, interp.get(s)); 								// put (s, s.value) into reduced
				}
				if(checkPresent(query,reduced))										// check whether all vars in reduced appear in query
					interp = reduced;
			}
		}
		return InterptoCube(interp);
	}
	
	// Convert an interpretation to a Z3 Expr, such that the Expr is ture <=> all var are assigned as the given interp
	public BoolExpr InterptoExpr(Map<Symbol,Boolean> interp){
		Expr result = null;
		Expr t = ctx.mkTrue();
		Expr f = ctx.mkFalse();
		Integer size = interp.size();
		Integer i = 0;
		Expr[] args = new Expr[size];
		for(Symbol s: interp.keySet()){
			if(interp.get(s))
				args[i] = ctx.mkEq(ctx.mkBoolConst(s), t);
			else
				args[i] = ctx.mkEq(ctx.mkBoolConst(s), f);
			i++;
		}
		return ctx.mkAnd((BoolExpr[]) args);
	}
	
	// Convert an interpretation to a Cube
	public Cube InterptoCube(Map<Symbol,Boolean> interp){
		Set<Expr> positives = new HashSet<>();
		Set<Expr> negatives = new HashSet<>();
		for (Symbol s : interp.keySet()) {
			if (interp.get(s)) {
				positives.add(ctx.mkBoolConst(s));
			} else {
				negatives.add(ctx.mkBoolConst(s));
			}
		}
		return new Cube(positives, negatives,ctx);
	}
	
	// Convert a Cube to a Z3 Expr
		public BoolExpr CubetoExpr(Cube c){
			Set<Expr> positives = c.pos;
			Set<Expr> negatives = c.neg;
			Integer size = positives.size() + negatives.size();
			BoolExpr[] args = new BoolExpr[size];
			Integer i = 0;
			for(Expr e: positives){
				args[i] = ctx.mkBoolConst(e.getFuncDecl().getName());
				i++;
			}
			for(Expr e: negatives){
				args[i] = ctx.mkNot(ctx.mkBoolConst(e.getFuncDecl().getName()));
				i++;
			}
			return ctx.mkAnd(args);
		}
	
    Optional<Model> check(Context ctx, BoolExpr f, Status sat)
    {
        Solver s = ctx.mkSolver();
        s.add(f);
        if (s.check() != sat)
            return null;
        if (sat == Status.SATISFIABLE)
            return Optional.of(s.getModel());
        else
            return null;
    }
    
	public PDR(Expr I, Expr T, Expr P, Context ctx){
		this.I = I;
		this.T = T;
		this.P = P;
		this.ctx = ctx;
	}
	
	public Cube ModeltoCube(Model mo){
		Set<Expr> positives = new HashSet<>();
		Set<Expr> negatives = new HashSet<>();
		for(FuncDecl f: mo.getConstDecls()){
			if(mo.getConstInterp(f).isTrue()){
				positives.add(ctx.mkBoolConst(f.getName()));
			}else
				negatives.add(ctx.mkBoolConst(f.getName()));
		}
		return new Cube(positives,negatives,ctx);
	}
	
	// Check whether all vars in interp appear in query
	public boolean checkPresent(Expr query, Map<Symbol,Boolean> interp){
		boolean flag;							
		for(Symbol s: interp.keySet()){
			flag = false;		
			for(Expr e: query.getArgs()){
				if(s.toString().equals(e.getFuncDecl().getName().toString()))
					flag = true;												// we found a s in e so turn flag to true
			}
			if(!flag)															// return false when s not in e
				return false;
		}
		return true;
	}
	
	// Check whether an interpretation satisfy a given query
	public boolean check(Expr query, Map<Symbol,Boolean> interp){
		Solver s = ctx.mkSolver();
        s.add(ctx.mkAnd((BoolExpr)query,InterptoExpr(interp)));
        if (s.check() == Status.SATISFIABLE)
            return true;
        else
        	return false;
	}
}
